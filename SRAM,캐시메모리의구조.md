### 캐시 메모리,SRAM

캐시 메모리와 SRAM은 플립플롭의 형태를 써서 저장한다.

앞서 설명했던 플립플롭은 bjt로 만든 것이기 때문에 실제 sram과 같은 전자기기에는

 cmos를 사용해서 플립플롭과 래치를 만들기 때문에

이번에는 cmos를 써서 플립플롭의 구조를 설명하겠다.

기본적으로 cmos 플립플롭은 인버터를 사용해서 저장한다.

인버터란 상태의 값을 반대로 출력하는 장치인데

구조는 입력값을 서로다른 nmos와 pmos의 게이트에 연결하는 형태이다.

그리고 두 cmos의 출력을 하나의 도선으로 연결하면 인버터의 완성이다.

이러한 인버터를 사용해서 어떻게 저장하냐 라고 한다면

인버터의 출력값을 다시 다른 인버터에 연결한다.

그리고 그 인버터의 출력값을 다시 아까 전의 인버터에 연결한다.

그러면 한쪽은 1이 다른 한 쪽은 0이 계속 반복되는 형태로 유지된다.

이 유지된 상태의 중간에 vdd(양전압)와 vss(음전압)을 연결해 놓는다.

여기서 vdd와 vss는 각각 판의 형태로 존재하고 

다른 곳의 vdd, vss는 서로 판을 공유하는 형태로 되어있다.

왜 vdd랑 vss를 연결하냐 고 말한다면

사실 저장하는 곳은 엄연히 말하면 인버터의 경로이다.

왼쪽 인버터는 nmos경로를 통하고 오른쪽 인버터는 pmos경로를 통하는 

것을 보고 나중에 불러오기를 했을 때 비트 라인에 1이 나오는구나

하고 아는 것이다.

그리고 이러한 인버터의 경로를 유지하기 위해서는 지속적인 전원 공급이 필요하다.

그러기 위해 따로 vdd와 vss가 있는 것이다.

즉 vdd와 vss로 생기는 전류를 어떤 경로로 흐르는 가 =  저장 

인 것이다.

근데 여기서 캐시 메모리의 경우 중요한 것이 있다.

위의 구조는 래치 라고 하는 형식일 뿐이다.

플립플롭과 래치의 차이는 클럭 신호를 쓰냐 안쓰냐의 차이인 것이다.

캐시 메모리는 cpu의 클럭신호를 가지고 저장한다.

왜 클럭신호를 가지고 저장하는가 하면 

그냥 값이 변경하는 대로 저장하면 cpu의 동작과 안 맞을 수 있고

데이터 경합같은 문제가 발생할 수 있기 때문에 

클럭신호를 가지고 동기화를 하는 것이다.

클럭신호를 통해 저장하는 방식도 크게 2가지가 존재한다.

1.마스터-슬레이브 구조

이 구조는 클럭이 0에서 1이 되고 다시 0으로 되면 저장되는 구조이다.

자세히 설명하자면 0에서 1이 될 때 마스터 부분에 저장을 하고

다시 1에서 0이 되면 마스터에서 나온 값을 슬레이브로 들어가서

최종 저장장소(q)에 저장하는 방식인 것이다.

여기서 위에서 설명한 저장장소(q)가 바로 피드백구조(래치 구조) 인 것이다.

그러면 마스터와 슬레이브 구조는 어떻게 되어 있냐면

먼저 클럭신호와 비트라인이  존재한다.

여기서 비트라인 쪽에 nmos를 연결한다.

그리고 nmos의 게이트를 클럭신호와 연결한다.

이러면 클럭신호가 1일 때만 비트라인의 값이 이동할 수 있다.

그 다음 인버터를 2개 직렬로 연결한다.

인버터를 2개 연결하면 결국 같은 값으로 나오는데

그럼에도 이러한 인버터를 굳이 사용하는 이유는

데이터를 보내는 신호(전압)이 길어질 수록 노이즈가 발생하고

저항이 강해져서 신호가 약해지기 때문에

인버터에 연결된 nmos와 pmos에 있는 전류로 갈아껴준 것이다.

여기까지가 마스터 구조이다.

그 다음 인버터를 지나서 나온 출력 값을 다시 위에서 본 인버터 2개와 연결하는데 

그 전에 이번에는 pmos를 그 사이에 연결한다.

당연히 pmos의 게이트는 클럭신호를 받는다.

이렇게 하면 클럭신호 값이 0이여야 값을 지나가는 것이다.

그 이후는 마스터와 동일하다.

이렇게 마스터와 슬레이브 2가지의 과정을 거치는 이유는

클럭신호를 그대로 받아서 저장한다고 하면

클럭 도중에 저장하는 값이 변하거나 하는 상황에서 

오류가 발생할 수 있기 때문이다.

그리고 다른 2번째 방식은 엣지 트리거 방식이다.

클럭이 0→1이 될 때 상승하는 것, 1→0이 될 때 하강하는 것

이 두 가지 경우를 상승 엣지, 하강 엣지라고 한다.

상승 엣지일 때 1번 동작하고 하강 엣지일 때 1번 동작하면

클럭 1번에 동작이 2번 하는 것이 되는 것이다.

이 방식을 사용하면 오실레이터를 2배 빠르게 하지 않아도 

2배 빠른 클럭을 얻을 수 있는 것이다.

(물론 그만큼 cpu가 처리할 수 있어야 하고, 다른 부품들도 그 속도를 따라와야 한다.)

엣지 트리거의 방식 중에서 가장 대표적인 것이

듀얼 엣지 트리거 방식이다.

구조는

2개의 래치와 그 래치의 값을 멀티플렉서에 넣어서 출력하는 방식이다.

먼저 2개의 래치에는 각 각 클럭과 클럭바(반대신호)를 보낸다.

여기서 아주 중요한 점이 있다.

엣지 트리거라는 것은 상승엣지, 하강엣지에서만 동작해야 하는데

저 말은 상승하는 아주 짧은 순간, 하강하는 아주 짧은 순간 만 동작해야 한다는 점이다.

이것은 단순히 래치2개와 멀티플렉서로 구현할 수 있는 것이 아니다.

이러한 짧은 활성화 시간을 구현하기 위해서는

클럭신호와 지연된 클럭신호가 필요하다.

여기서 지연된 클럭신호를 만드는 법은 인버터를 여러 개 연결하면 된다.

많이 연결할 수록 더욱 시간이 지연된다.( 물론 짝수 개로 설치해야 함.)

이렇게 만든 클럭,지연 클럭을 가지고

and게이트와 not게이트로 상승 엣지와 하강엣지를 따로 만든다.

먼저 상승 엣지부터 만들어 보자면

결국 클럭과 지연 클럭이 00인 상태에서 클럭이 1이 되는 순간에 10이 될 때

1이 출력 되고 나머지 11,01,00은 0이 출력 돼야 한다.

그러기 위해서 일단 지연 클럭이 0인 상태에서 1이 출력되야 하니까

not게이트로 반전을 걸어준다.

그러면  00, 10, 11, 01 이 01,11,10,00 이 되기 때문에

10 입력만이 11이 돼서 1이 출력하게 된다.

반대의 하강 엣지도 다르지 않다.

이번에는 01만 1이 나와야 하기 때문에

클럭신호를 not게이트로 반전을 걸어주면

00,10,11,01 이 10,00,01,11 이 돼서 01만 1이 출력하게 된다.

이렇게 엣지만 실행하게 만든 다음

각 각 래치를 걸어준다.

그 다음 이걸 멀티 플렉서로 정해서 보내는 작업을 한다.

멀티 플렉서를 쓰는 이유는 각 각의 래치에서 데이터를 저장하는 행동을 하는데

이 과정이 래치마다 조금씩 차이가 발생 할 수 있다.

그리고 그 차이가 클럭신호와 맞부딪치게 되면 큰 오류가 발생 할 수 있다.

결국 상승 엣지와 하강 엣지를 나눠서 작동해야 해서 래치를 여러 개 써야 하고

여러 개 쓰니까 래치 간의 차이가 발생할 수 있어서 멀티플렉서로 동기화를 해주는 것이다.

그 후 멀티플렉서에서 나온 값을 피드백 구조의 래치로 저장하는 것이다.
